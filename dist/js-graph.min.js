/* js-graph - v0.1.0 - 2014-04-19 */
"use strict";!function(a,b,c){"function"==typeof define&&define.amd?define([],c):"object"==typeof exports?module.exports=c():a[b]=c()}(this,"JsGraph",function(){function a(){var c=this,d={},e={},f={},g=0,h=0,i=new b,j=new b;c.onAddVertex=i.add,c.onRemoveVertex=j.add,c.addNewVertex=function(b,h){if(c.hasVertex(b))throw new a.VertexExistsError(b,d[b]);d[b]=h,e[b]={},f[b]={},g+=1,i.fire(b,h)},c.setVertex=function(b,e){if(!c.hasVertex(b))throw new a.VertexNotExistsError(b);d[b]=e},c.ensureVertex=function(a,b){c.hasVertex(a)||c.addNewVertex(a,b)},c.addVertex=function(a,b){c.hasVertex(a)?c.setVertex(a,b):c.addNewVertex(a,b)},c.removeExistingVertex=function(b){if(!c.hasVertex(b))throw new a.VertexNotExistsError(b);if(Object.keys(e[b]).length)throw new a.HasConnectedEdgesError(b);if(Object.keys(f[b]).length)throw new a.HasConnectedEdgesError(b);var h=d[b];delete d[b],g-=1,j.fire(b,h)},c.destroyExistingVertex=function(b){if(!c.hasVertex(b))throw new a.VertexNotExistsError(b);c.eachVertexFrom(b,function(a){c.removeEdge(b,a)}),c.eachVertexTo(b,function(a){c.removeEdge(a,b)}),c.removeExistingVertex(b)},c.removeVertex=function(a){c.hasVertex(a)&&c.removeExistingVertex(a)},c.destroyVertex=function(a){c.hasVertex(a)&&c.destroyExistingVertex(a)};var k=new b,l=new b;c.onAddEdge=k.add,c.onRemoveEdge=l.add,c.addNewEdge=function(b,d,g){if(c.hasEdge(b,d))throw new a.EdgeExistsError(b,d,c.edgeValue(b,d));if(!c.hasVertex(b))throw c.hasVertex(d)?new a.VertexNotExistsError(b):new a.VertexNotExistsError(b).v(d);if(!c.hasVertex(d))throw new a.VertexNotExistsError(d);e[b][d]=g,f[d][b]=null,h+=1,k.fire(b,d,g)},c.createNewEdge=function(b,d,e){if(c.hasEdge(b,d))throw new a.EdgeExistsError(b,d,c.edgeValue(b,d));c.ensureVertex(b),c.ensureVertex(d),c.addNewEdge(b,d,e)},c.setEdge=function(b,d,f){if(!c.hasEdge(b,d))throw new a.EdgeNotExistsError(b,d);e[b][d]=f},c.spanEdge=function(b,d,e){if(!c.hasVertex(b))throw c.hasVertex(d)?new a.VertexNotExistsError(b):new a.VertexNotExistsError(b).v(d);if(!c.hasVertex(d))throw new a.VertexNotExistsError(d);c.hasEdge(b,d)||c.addNewEdge(b,d,e)},c.addEdge=function(a,b,d){c.hasEdge(a,b)?c.setEdge(a,b,d):c.addNewEdge(a,b,d)},c.ensureEdge=function(a,b,d){c.hasEdge(a,b)||c.createNewEdge(a,b,d)},c.createEdge=function(a,b,d){c.hasEdge(a,b)?c.setEdge(a,b,d):c.createNewEdge(a,b,d)},c.removeExistingEdge=function(b,d){if(!c.hasEdge(b,d))throw new a.EdgeNotExistsError(b,d);if("undefined"!=typeof e[b]){var g=e[b][d];delete e[b][d]}"undefined"!=typeof f[d]&&delete f[d][b],h-=1,l.fire(b,d,g)},c.removeEdge=function(a,b){c.hasEdge(a,b)&&c.removeExistingEdge(a,b)},c.vertexCount=function(){return g},c.hasVertex=function(a){return a in d},c.vertexValue=function(a){return d[a]},c.edgeCount=function(){return h},c.hasEdge=function(a,b){return c.hasVertex(a)&&c.hasVertex(b)&&a in e&&b in e[a]},c.edgeValue=function(a,b){return c.hasEdge(a,b)?e[a][b]:void 0},c.eachVertex=function(a){Object.keys(d).forEach(function(b){a(b,d[b])})},c.eachVertexFrom=function(b,d){if(!c.hasVertex(b))throw new a.VertexNotExistsError(b);Object.keys(e[b]).forEach(function(a){d(a,c.vertexValue(a),c.edgeValue(b,a))})},c.eachVertexTo=function(b,d){if(!c.hasVertex(b))throw new a.VertexNotExistsError(b);Object.keys(f[b]).forEach(function(a){d(a,c.vertexValue(a),c.edgeValue(a,b))})},c.eachEdge=function(a){Object.keys(e).forEach(function(b){Object.keys(e[b]).forEach(function(c){a(b,c,e[b][c])})})},c.clearEdges=c.eachEdge.bind(void 0,c.removeEdge),c.clear=c.eachVertex.bind(void 0,c.destroyVertex),c.hasPath=function(a,b){function d(a){if(c.hasEdge(a,b))return!0;e[a]=!0;var f=!1;return c.eachVertexFrom(a,function(a){f||e[a]||!d(a)||(f=!0)}),delete e[a],f}if(!c.hasVertex(a)||!c.hasVertex(b))return!1;var e={};return d(a)},c.topologically=function(b){function d(g){e.push(g);var h=e.indexOf(g);if(h!==e.length-1){var i=e.slice(h+1).reverse();throw new a.CycleError(i)}f[g]||(c.eachVertexTo(g,d),f[g]={returned:b(g,c.vertexValue(g))}),e.pop()}var e=[],f={};c.eachVertex(function(a){f[a]||d(a)})}}function b(){var a=[];this.add=function(b){return-1===a.indexOf(b)&&a.push(b),function(){var c=a.indexOf(b);-1!==c&&a.splice(c,1)}},this.fire=function(){var b=arguments;a.forEach(function(a){a.apply(null,b)})}}function c(a,b){return b.prototype.__proto__=Error.prototype,b.prototype.constructor=b,b.prototype.name=a,b}return a.VertexExistsError=c("VertexExistsError",function(a,b){function c(){d.message="This graph has "+(1===d.vertices?"a vertex":"vertices")+" '"+Object.keys(d.vertices).join("', '")+"'"}var d=this;d.v=function(a,b){return d.vertices[a]=b,c(),d},d.vertices={},"undefined"!=typeof a&&d.v(a,b),c()}),a.VertexNotExistsError=c("VertexNotExistError",function(a){function b(){c.message="This graph does not have "+(1===c.vertices?"a vertex":"vertices")+" '"+Object.keys(c.vertices).join("', '")+"'"}var c=this;c.v=function(a){return c.vertices[a]=void 0,b(),c},c.vertices={},"undefined"!=typeof a&&c.v(a),b()}),a.EdgeExistsError=c("EdgeExistsError",function(a,b,c){function d(){var a=[];Object.keys(e.edges).forEach(function(b){Object.keys(e.edges[b]).forEach(function(c){a.push("('"+b+"', '"+c+"')")})}),e.message="This graph has "+(1===a.length?"an edge ":"edges ")+a.join(", ")}var e=this;e.e=function(a,b,c){return"undefined"==typeof e.edges[a]&&(e.edges[a]={}),e.edges[a][b]=c,d(),e},e.edges={},"undefined"!=typeof a&&"undefined"!=typeof b&&e.e(a,b,c),d()}),a.EdgeNotExistsError=c("EdgeNotExistError",function(a,b){function c(){var a=[];Object.keys(d.edges).forEach(function(b){Object.keys(d.edges[b]).forEach(function(c){a.push("('"+b+"', '"+c+"')")})}),d.message="This graph does not have "+(1===a.length?"an edge ":"edges ")+a.join(", ")}var d=this;d.e=function(a,b){return"undefined"==typeof d.edges[a]&&(d.edges[a]={}),d.edges[a][b]=void 0,c(),d},d.edges={},"undefined"!=typeof a&&"undefined"!=typeof b&&d.e(a,b),c()}),a.HasConnectedEdgesError=c("HasConnectedEdgesError",function(a){this.message="The '"+a+"' vertex has connected edges",this.key=a}),a.CycleError=c("CycleError",function(a){this.message="This graph contains a cycle: "+this.cycle,this.cycle=a}),a});
//# sourceMappingURL=js-graph.min.map